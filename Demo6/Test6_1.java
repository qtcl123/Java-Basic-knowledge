 package Demo6;
//static静态关键字
/*
 *用法 ：是一个修饰符  用于修饰成员（成员变量  成员函数）
 *static的由来：当创建一个类后   初始化一个对象   在堆内存中就会产生一个Persion();
 *在栈内存中就会存在变量p引用Persion()   
 *因为在类中有	country = "CN"; 相当于给每一个对象进行初始化了  而且每一个对象初始化都是country = "CN"
 *因此引入static将成员变量country进行静态化     使之均能访问
 * 
 *当成员被静态修饰后   就多了一个调用方式   除了可以被对象调用外  还可以直接  被类名调用  使用方式：类名.静态成员
 *
 *
 *
 *
 *静态有利有弊
 *利：对对象的共享数据进行单独空间的存储   节省空间   没有必要 每一个对象中都存储一份
 *   可以直接被类名调用
 *  
 *弊：生命周期长   访问出现局限性（静态虽好  只能访问静态）
 *
 *
 * 
 * 
 * 
 * 
 * */
public class Test6_1 
{
	public static void main(String[] args)
	{

		//Persion  p = new Persion();
		//p.name = "zhangsan";
		//p.show();
		
		//直接被类调用
		Persion.show();
		
		
	}
}



//类中的方法和静态变量存储于方法区域
/*static 的特点 
 * 1 随着类的加载儿加载：当使用该类时   静态变量就会存在内存中；同理会随着类的消失而消失   使用寿命最长  但是较占用内存
 * 
 * 2 被所有对象所共享
 * 明确一点：静态先存在   对象后存在
 * 
 * 
 * 3 优先于对象存在
 * 4 可以直接被类名调用
 * 
 * 
 *类变量和实例变量的区别:
 *1 存放位置
 *类变量随着类的加载 而存在于方法区中 
 *实例变量随着对象的创建而存在于堆内存中
 *
 *2 生命周期：
 *类变量生命周期最长  随着类的消失而消失
 *实例变量生命周期随着对象的消失而消失
 *
 *
 *静态使用注意事项：
 *1 静态方法只能访问静态成员(属性和方法)
 *   非静态方法即可以访问静态  也可以访问非静态
 *   
 *2 静态方法中可以不定义this关键字   super关键字
 *因为静态优先于对象存在  所以静态方法中不可以出现this    因为this代表对象
 *
 *3 主函数是静态的
 
 
 * */

class Persion 
{
	//成员变量   实例变量
	String name;   //特有数据  在堆内存中和对象共存     当对象创建时  才会存在与内存中
	
	//静态的成员变量 类变量
	static String country = "CN";  //被静态修饰    相当于各个对象共享  存在于方法区（共享区 数据区）
	
	public static void show()
	{
		System.out.println("::"+country);
	
	}
	
	
	
	
}


